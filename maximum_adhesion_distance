core/PhysiCell_cell.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_cell.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_cell.cpp:# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
core/PhysiCell_cell.cpp:#    llelized diffusive transport solver for 3-D biological simulations,      #
core/PhysiCell_cell.cpp:#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730   #
core/PhysiCell_cell.cpp:# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
core/PhysiCell_cell.cpp:# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
core/PhysiCell_cell.cpp:	o2_hypoxic_threshold = 15.0; // HIF-1alpha at half-max around 1.5-2%, and tumors often are below 2%
core/PhysiCell_cell.cpp:	o2_hypoxic_response = 8.0; // genomic / proteomic changes observed at 7-8 mmHg 
core/PhysiCell_cell.cpp:	o2_hypoxic_saturation = 4.0; // maximum HIF-1alpha at 0.5% o2 (McKeown)
core/PhysiCell_cell.cpp:		double one_minus_bias = 1.0 - phenotype.motility.migration_bias; 
core/PhysiCell_cell.cpp:		axpy( &(phenotype.motility.motility_vector), one_minus_bias, randvec ); // motility = (1-bias)*randvec + bias*bias_vector
core/PhysiCell_cell.cpp:	current_mechanics_voxel_index=-1;
core/PhysiCell_cell.cpp:	get_container()->flag_cell_for_division( this );
core/PhysiCell_cell.cpp:	get_container()->flag_cell_for_removal( this );
core/PhysiCell_cell.cpp:		double z= 2* UniformRandom()-1;
core/PhysiCell_cell.cpp:		double temp= sqrt(1-z*z);
core/PhysiCell_cell.cpp:	child->copy_data( this );	
core/PhysiCell_cell.cpp:	child->copy_function_pointers(this);
core/PhysiCell_cell.cpp:	child->parameters = parameters;
core/PhysiCell_cell.cpp:	// child->register_microenvironment( get_microenvironment() );
core/PhysiCell_cell.cpp:	rand_vec = rand_vec- phenotype.geometry.polarity*(rand_vec[0]*state.orientation[0]+ 
core/PhysiCell_cell.cpp:	if( norm(rand_vec) < 1e-16 )
core/PhysiCell_cell.cpp:	child->assign_position(position[0] + 0.5 * radius*rand_vec[0],
core/PhysiCell_cell.cpp:	static double negative_one_half = -0.5; 
core/PhysiCell_cell.cpp:	naxpy( &position, negative_one_half , rand_vec );// position = position - 0.5*rand_vec; 
core/PhysiCell_cell.cpp:	// position[0] -= 0.5*radius*rand_vec[0];
core/PhysiCell_cell.cpp:	// position[1] -= 0.5*radius*rand_vec[1]; 
core/PhysiCell_cell.cpp:	// position[2] -= 0.5*radius*rand_vec[2]; 
core/PhysiCell_cell.cpp:	child->phenotype.volume.divide();
core/PhysiCell_cell.cpp:	child->set_total_volume(child->phenotype.volume.total);
core/PhysiCell_cell.cpp:	// child->set_phenotype( phenotype ); 
core/PhysiCell_cell.cpp:	child->phenotype = phenotype; 
core/PhysiCell_cell.cpp:	if( !get_container()->underlying_mesh.is_position_valid(x,y,z) )
core/PhysiCell_cell.cpp:	current_mechanics_voxel_index= get_container()->underlying_mesh.nearest_voxel_index( position );
core/PhysiCell_cell.cpp:	get_container()->register_agent(this);
core/PhysiCell_cell.cpp:	// current total volume, adjust all the sub-volumes 
core/PhysiCell_cell.cpp:	// if( fabs( phenotype.volume.total - volume ) < 1e-16 )
core/PhysiCell_cell.cpp:	if( fabs( phenotype.volume.total - volume ) > 1e-16 )
core/PhysiCell_cell.cpp:	//if( get_container()->max_cell_interactive_distance_in_voxel[get_current_mechanics_voxel_index()] < 
core/PhysiCell_cell.cpp:	if( get_container()->max_cell_interactive_distance_in_voxel[get_current_mechanics_voxel_index()] < 
core/PhysiCell_cell.cpp:		// get_container()->max_cell_interactive_distance_in_voxel[get_current_mechanics_voxel_index()]= phenotype.geometry.radius*parameters.max_interaction_distance_factor;
core/PhysiCell_cell.cpp:		get_container()->max_cell_interactive_distance_in_voxel[get_current_mechanics_voxel_index()] = phenotype.geometry.radius
core/PhysiCell_cell.cpp:		container = (Cell_Container *)get_microenvironment()->agent_container;
core/PhysiCell_cell.cpp:	// use Adams-Bashforth 
core/PhysiCell_cell.cpp:		d2 *= -0.5; 
core/PhysiCell_cell.cpp:	if(get_container()->underlying_mesh.is_position_valid(position[0],position[1],position[2]))
core/PhysiCell_cell.cpp:		updated_current_mechanics_voxel_index=get_container()->underlying_mesh.nearest_voxel_index( position );
core/PhysiCell_cell.cpp:		updated_current_mechanics_voxel_index=-1;
core/PhysiCell_cell.cpp:	// if(!get_container()->underlying_mesh.is_position_valid(position[0],position[1],position[2]))	
core/PhysiCell_cell.cpp:	if(updated_current_mechanics_voxel_index==-1)// updated_current_mechanics_voxel_index is updated in update_position
core/PhysiCell_cell.cpp:			{get_container()->remove_agent_from_voxel(this, get_current_mechanics_voxel_index());}
core/PhysiCell_cell.cpp:		{get_container()->add_agent_to_outer_voxel(this);}
core/PhysiCell_cell.cpp:		current_mechanics_voxel_index=-1;
core/PhysiCell_cell.cpp:	// updated_current_mechanics_voxel_index=get_container()->underlying_mesh.nearest_voxel_index( position );
core/PhysiCell_cell.cpp:			container->remove_agent_from_voxel(this, get_current_mechanics_voxel_index());
core/PhysiCell_cell.cpp:			container->add_agent_to_voxel(this, updated_current_mechanics_voxel_index);
core/PhysiCell_cell.cpp:	// phenotype=copyMe-> phenotype; //it is taken care in set_phenotype
core/PhysiCell_cell.cpp:	type = copy_me->type; 
core/PhysiCell_cell.cpp:	type_name = copy_me->type_name; 
core/PhysiCell_cell.cpp:	custom_data = copy_me->custom_data; 
core/PhysiCell_cell.cpp:	parameters = copy_me->parameters; 
core/PhysiCell_cell.cpp:	velocity = copy_me->velocity; 
core/PhysiCell_cell.cpp:	// expected_phenotype = copy_me-> expected_phenotype; //it is taken care in set_phenotype
core/PhysiCell_cell.cpp:	cell_source_sink_solver_temp1 = std::vector<double>(copy_me->cell_source_sink_solver_temp1);
core/PhysiCell_cell.cpp:	cell_source_sink_solver_temp2 = std::vector<double>(copy_me->cell_source_sink_solver_temp2);
core/PhysiCell_cell.cpp:	functions = copy_me->functions; 
core/PhysiCell_cell.cpp:	if( this->ID == other_agent->ID )
core/PhysiCell_cell.cpp:	static double simple_pressure_scale = 0.027288820670331; // 12 * (1 - sqrt(pi/(2*sqrt(3))))^2 
core/PhysiCell_cell.cpp:	// 9.820170012151277; // 12 * ( 1 - sqrt(2*pi/sqrt(3)))^2
core/PhysiCell_cell.cpp:		displacement[i] = position[i] - (*other_agent).position[i]; 
core/PhysiCell_cell.cpp:		// c = 1.0 - RN/R; 
core/PhysiCell_cell.cpp:		// c -= M; 
core/PhysiCell_cell.cpp:		// temp_r = 1 - distance/R;
core/PhysiCell_cell.cpp:		temp_r = -distance; // -d
core/PhysiCell_cell.cpp:		temp_r /= R; // -d/R
core/PhysiCell_cell.cpp:		temp_r += 1.0; // 1-d/R
core/PhysiCell_cell.cpp:		temp_r *= temp_r; // (1-d/R)^2 
core/PhysiCell_cell.cpp:	// August 2017 - back to the original if both have same coefficient 
core/PhysiCell_cell.cpp:	double effective_repulsion = sqrt( phenotype.mechanics.cell_cell_repulsion_strength * other_agent->phenotype.mechanics.cell_cell_repulsion_strength ); 
core/PhysiCell_cell.cpp:		// double temp_a = 1 - distance/max_interactive_distance; 
core/PhysiCell_cell.cpp:		double temp_a = -distance; // -d
core/PhysiCell_cell.cpp:		temp_a /= max_interactive_distance; // -d/S
core/PhysiCell_cell.cpp:		temp_a += 1.0; // 1 - d/S 
core/PhysiCell_cell.cpp:		temp_a *= temp_a; // (1-d/S)^2 
core/PhysiCell_cell.cpp:		// August 2017 - back to the original if both have same coefficient 
core/PhysiCell_cell.cpp:		double effective_adhesion = sqrt( phenotype.mechanics.cell_cell_adhesion_strength * other_agent->phenotype.mechanics.cell_cell_adhesion_strength ); 
core/PhysiCell_cell.cpp:		temp_r -= temp_a;
core/PhysiCell_cell.cpp:	if( fabs(temp_r) < 1e-16 )
core/PhysiCell_cell.cpp:	pNew->index=(*all_cells).size()-1;
core/PhysiCell_cell.cpp:		pNew->register_microenvironment( BioFVM::get_default_microenvironment() );
core/PhysiCell_cell.cpp:	pNew->type = cd.type; 
core/PhysiCell_cell.cpp:	pNew->type_name = cd.name; 
core/PhysiCell_cell.cpp:	pNew->custom_data = cd.custom_data; 
core/PhysiCell_cell.cpp:	pNew->parameters = cd.parameters; 
core/PhysiCell_cell.cpp:	pNew->functions = cd.functions; 
core/PhysiCell_cell.cpp:	pNew->phenotype = cd.phenotype; 
core/PhysiCell_cell.cpp:	pNew->is_movable = true;
core/PhysiCell_cell.cpp:	pNew->is_out_of_domain = false;
core/PhysiCell_cell.cpp:	pNew->displacement.resize(3,0.0); // state? 
core/PhysiCell_cell.cpp:	pNew->assign_orientation();
core/PhysiCell_cell.cpp:	(*all_cells)[index]->get_container()->remove_agent((*all_cells)[index]);
core/PhysiCell_cell.cpp:	// de-allocate (delete) the cell; 
core/PhysiCell_cell.cpp:	// performance goal: don't delete in the middle -- very expensive reallocation
core/PhysiCell_cell.cpp:	(*all_cells)[ (*all_cells).size()-1 ]->index=index;
core/PhysiCell_cell.cpp:	(*all_cells)[index] = (*all_cells)[ (*all_cells).size()-1 ];
core/PhysiCell_cell.cpp:	delete_cell(pDelete->index);
core/PhysiCell_cell.cpp:	double max_interactive_distance = pCell->phenotype.mechanics.relative_maximum_adhesion_distance * pCell->phenotype.geometry.radius 
core/PhysiCell_cell.cpp:		+ pCell->get_container()->max_cell_interactive_distance_in_voxel[other_voxel_index];
core/PhysiCell_cell.cpp:	int comparing_dimension = -1, comparing_dimension2 = -1;
core/PhysiCell_cell.cpp:	if(comparing_dimension != -1) 
core/PhysiCell_cell.cpp:		if(std::fabs(pCell->position[comparing_dimension] - surface_coord) > max_interactive_distance)
core/PhysiCell_cell.cpp:	comparing_dimension=-1;
core/PhysiCell_cell.cpp:	if(comparing_dimension != -1)
core/PhysiCell_cell.cpp:		double distance_squared= std::pow( pCell->position[comparing_dimension] - line_coord1,2)+ std::pow( pCell->position[comparing_dimension2] - line_coord2,2);
core/PhysiCell_cell.cpp:	double distance_squared= (corner_point[0]-pCell->position[0])*(corner_point[0]-pCell->position[0])
core/PhysiCell_cell.cpp:		+(corner_point[1]-pCell->position[1])*(corner_point[1]-pCell->position[1]) 
core/PhysiCell_cell.cpp:		+(corner_point[2]-pCell->position[2]) * (corner_point[2]-pCell->position[2]);
core/PhysiCell_cell.cpp:	return get_container()->agent_grid[get_current_mechanics_voxel_index()];
core/PhysiCell_cell_container.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_cell_container.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_cell_container.cpp:# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
core/PhysiCell_cell_container.cpp:#    llelized diffusive transport solver for 3-D biological simulations,      #
core/PhysiCell_cell_container.cpp:#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730   #
core/PhysiCell_cell_container.cpp:# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
core/PhysiCell_cell_container.cpp:# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
core/PhysiCell_cell_container.cpp:	double time_since_last_cycle= t- last_cell_cycle_time;
core/PhysiCell_cell_container.cpp:	if( fabs(time_since_last_cycle- phenotype_dt_ ) < phenotype_tolerance || !initialzed)
core/PhysiCell_cell_container.cpp:			if((*all_cells)[i]->is_out_of_domain)
core/PhysiCell_cell_container.cpp:			(*all_cells)[i]->update_cell_and_death_parameters((*all_cells)[i],cell_cycle_dt);
core/PhysiCell_cell_container.cpp:			(*all_cells)[i]->advance_cell_current_phase((*all_cells)[i],time_since_last_cycle);
core/PhysiCell_cell_container.cpp:			(*all_cells)[i]->update_volume((*all_cells)[i], time_since_last_cycle ); 
core/PhysiCell_cell_container.cpp:		// new as of 1.2.1 -- bundles cell phenotype parameter update, volume update, geometry update, 
core/PhysiCell_cell_container.cpp:			if((*all_cells)[i]->is_out_of_domain)
core/PhysiCell_cell_container.cpp:			// (*all_cells)[i]->phenotype.advance_bundled_models( (*all_cells)[i] , time_since_last_cycle ); 
core/PhysiCell_cell_container.cpp:			(*all_cells)[i]->advance_bundled_phenotype_functions( time_since_last_cycle ); 
core/PhysiCell_cell_container.cpp:			cells_ready_to_divide[i]->divide();
core/PhysiCell_cell_container.cpp:			cells_ready_to_die[i]->die();	
core/PhysiCell_cell_container.cpp:	double time_since_last_mechanics= t- last_mechanics_time;
core/PhysiCell_cell_container.cpp:	if( fabs(time_since_last_mechanics - mechanics_dt_)< mechanics_tolerance || !initialzed)
core/PhysiCell_cell_container.cpp:			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable)
core/PhysiCell_cell_container.cpp:				//(*all_cells)[i]->phenotype.motility.update_motility_vector( (*all_cells)[i] ,(*all_cells)[i]->phenotype , time_since_last_mechanics ); 
core/PhysiCell_cell_container.cpp:				(*all_cells)[i]->functions.update_velocity( (*all_cells)[i], (*all_cells)[i]->phenotype, time_since_last_mechanics);
core/PhysiCell_cell_container.cpp:			if( (*all_cells)[i]->functions.custom_cell_rule )
core/PhysiCell_cell_container.cpp:				(*all_cells)[i]->functions.custom_cell_rule((*all_cells)[i], (*all_cells)[i]->phenotype, time_since_last_mechanics);
core/PhysiCell_cell_container.cpp:			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable)
core/PhysiCell_cell_container.cpp:				(*all_cells)[i]->update_position(time_since_last_mechanics);
core/PhysiCell_cell_container.cpp:			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable)
core/PhysiCell_cell_container.cpp:				(*all_cells)[i]->update_voxel_in_container();
core/PhysiCell_cell_container.cpp:		(*all_cells)[i]->phenotype.secretion.advance( (*all_cells)[i], (*all_cells)[i]->phenotype , diffusion_dt_ );
core/PhysiCell_cell_container.cpp:	double time_since_last_cycle= t- last_cell_cycle_time;
core/PhysiCell_cell_container.cpp:	if( fabs(time_since_last_cycle-phenotype_dt_ ) < phenotype_dt_tolerance || !initialzed)
core/PhysiCell_cell_container.cpp:		// new as of 1.2.1 -- bundles cell phenotype parameter update, volume update, geometry update, 
core/PhysiCell_cell_container.cpp:			if((*all_cells)[i]->is_out_of_domain)
core/PhysiCell_cell_container.cpp:			// (*all_cells)[i]->phenotype.advance_bundled_models( (*all_cells)[i] , time_since_last_cycle ); 
core/PhysiCell_cell_container.cpp:			(*all_cells)[i]->advance_bundled_phenotype_functions( time_since_last_cycle ); 
core/PhysiCell_cell_container.cpp:			cells_ready_to_divide[i]->divide();
core/PhysiCell_cell_container.cpp:			cells_ready_to_die[i]->die();	
core/PhysiCell_cell_container.cpp:	double time_since_last_mechanics= t- last_mechanics_time;
core/PhysiCell_cell_container.cpp:	if( fabs(time_since_last_mechanics - mechanics_dt_) < mechanics_dt_tolerance || !initialzed)
core/PhysiCell_cell_container.cpp:			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable && (*all_cells)[i]->functions.update_velocity )
core/PhysiCell_cell_container.cpp:				//(*all_cells)[i]->phenotype.motility.update_motility_vector( (*all_cells)[i] ,(*all_cells)[i]->phenotype , time_since_last_mechanics ); 
core/PhysiCell_cell_container.cpp:				(*all_cells)[i]->functions.update_velocity( (*all_cells)[i], (*all_cells)[i]->phenotype, time_since_last_mechanics);
core/PhysiCell_cell_container.cpp:			if( (*all_cells)[i]->functions.custom_cell_rule )
core/PhysiCell_cell_container.cpp:				(*all_cells)[i]->functions.custom_cell_rule((*all_cells)[i], (*all_cells)[i]->phenotype, time_since_last_mechanics);
core/PhysiCell_cell_container.cpp:			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable)
core/PhysiCell_cell_container.cpp:				(*all_cells)[i]->update_position(time_since_last_mechanics);
core/PhysiCell_cell_container.cpp:			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable)
core/PhysiCell_cell_container.cpp:				(*all_cells)[i]->update_voxel_in_container();
core/PhysiCell_cell_container.cpp:	agent_grid[agent->get_current_mechanics_voxel_index()].push_back(agent);
core/PhysiCell_cell_container.cpp:	remove_agent_from_voxel(agent, agent->get_current_mechanics_voxel_index());
core/PhysiCell_cell_container.cpp:	agent->is_out_of_domain=true;
core/PhysiCell_cell_container.cpp:	agent_grid[agent->get_current_mechanics_voxel_index()][delete_index] = agent_grid[agent->get_current_mechanics_voxel_index()][agent_grid[agent->get_current_mechanics_voxel_index()].size()-1 ]; 
core/PhysiCell_cell_container.cpp:	agent_grid[agent->get_current_mechanics_voxel_index()].pop_back(); 
core/PhysiCell_cell_container.cpp:	if(agent->position[0] <= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_min_x_index])
core/PhysiCell_cell_container.cpp:	if(agent->position[0] >= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_max_x_index])
core/PhysiCell_cell_container.cpp:	if(agent->position[1] <= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_min_y_index])
core/PhysiCell_cell_container.cpp:	if(agent->position[1] >= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_max_y_index])
core/PhysiCell_cell_container.cpp:	if(agent->position[2] <= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_min_z_index])
core/PhysiCell_cell_container.cpp:	if(agent->position[2] >= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_max_z_index])
core/PhysiCell_cell_container.cpp:	return -1; 
core/PhysiCell_cell_container.cpp:	cell_container->initialize( m.mesh.bounding_box[0], m.mesh.bounding_box[3], 
core/PhysiCell_custom.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_custom.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_custom.cpp:# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
core/PhysiCell_custom.cpp:#    llelized diffusive transport solver for 3-D biological simulations,      #
core/PhysiCell_custom.cpp:#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730   #
core/PhysiCell_custom.cpp:# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
core/PhysiCell_custom.cpp:# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
core/PhysiCell_digital_cell_line.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_digital_cell_line.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_digital_cell_line.cpp:# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
core/PhysiCell_digital_cell_line.cpp:#    llelized diffusive transport solver for 3-D biological simulations,      #
core/PhysiCell_digital_cell_line.cpp:#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730   #
core/PhysiCell_digital_cell_line.cpp:# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
core/PhysiCell_digital_cell_line.cpp:# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.solid = DCL.phenotypes[i].volume.total - DCL.phenotypes[i].volume.fluid;
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.nuclear_solid = DCL.phenotypes[i].volume.nuclear -  DCL.phenotypes[i].volume.nuclear_fluid;
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.cytoplasmic = DCL.phenotypes[i].volume.total - DCL.phenotypes[i].volume.nuclear; 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.cytoplasmic_solid = DCL.phenotypes[i].volume.cytoplasmic -  DCL.phenotypes[i].volume.cytoplasmic_fluid;  
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].duration = 17.100027 * 60.0; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].death_rate = 0.026133 / 60.0; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[1].duration = 8.6 * 60.0; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[1].death_rate = 0; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[2].duration = 3.0 * 60.0; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[3].duration = 45.0 * 24.0 * 60.0; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].birth_rate = 3.1441e-04; 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].duration = 1.0 / DCL.phenotypes[i].cycle.phases[0].birth_rate; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].birth_rate = 1.8864e-05; // 0.9 * DCL.phenotypes[0].cycle.phases[0].birth_rate ;
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].duration = 1.0 / DCL.phenotypes[i].cycle.phases[0].birth_rate; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].duration = 1.0 / ( DCL.phenotypes[i].cycle.phases[0].birth_rate + 1e-16); // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.solid = DCL.phenotypes[i].volume.total - DCL.phenotypes[i].volume.fluid;
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.nuclear_solid = DCL.phenotypes[i].volume.nuclear -  DCL.phenotypes[i].volume.nuclear_fluid;
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.cytoplasmic = DCL.phenotypes[i].volume.total - DCL.phenotypes[i].volume.nuclear; 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.cytoplasmic_solid = DCL.phenotypes[i].volume.cytoplasmic -  DCL.phenotypes[i].volume.cytoplasmic_fluid;  
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[3].duration = 8.6 * 60.0; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[3].death_rate = 0; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[4].duration = 3.0 * 60.0; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[5].duration = 45.0 * 24.0 * 60.0; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].birth_rate = 3.1441e-04; // 0.9 * DCL.phenotypes[0].cycle.phases[0].birth_rate ;
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].duration = 1.0 / DCL.phenotypes[i].cycle.phases[0].birth_rate; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].birth_rate = 1.8864e-05; // 0.9 * DCL.phenotypes[0].cycle.phases[0].birth_rate ;
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].duration = 1.0 / DCL.phenotypes[i].cycle.phases[0].birth_rate; // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].cycle.phases[0].duration = 1.0 / ( DCL.phenotypes[i].cycle.phases[0].birth_rate + 1e-16); // minutes (MDA-MB-231) 
core/PhysiCell_digital_cell_line.cpp:	double divider= -log(.05);	
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.solid = DCL.phenotypes[i].volume.total - DCL.phenotypes[i].volume.fluid;
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.nuclear_solid = DCL.phenotypes[i].volume.nuclear -  DCL.phenotypes[i].volume.nuclear_fluid;
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.cytoplasmic = DCL.phenotypes[i].volume.total - DCL.phenotypes[i].volume.nuclear; 
core/PhysiCell_digital_cell_line.cpp:	DCL.phenotypes[i].volume.cytoplasmic_solid = DCL.phenotypes[i].volume.cytoplasmic -  DCL.phenotypes[i].volume.cytoplasmic_fluid;  
core/PhysiCell_phenotype.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_phenotype.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_phenotype.cpp:# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
core/PhysiCell_phenotype.cpp:#    llelized diffusive transport solver for 3-D biological simulations,      #
core/PhysiCell_phenotype.cpp:#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730   #
core/PhysiCell_phenotype.cpp:# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
core/PhysiCell_phenotype.cpp:# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
core/PhysiCell_phenotype.cpp:	int n = pCycle_Model->phases.size(); 
core/PhysiCell_phenotype.cpp:	for( int i=0 ; i < pCycle_Model->phase_links.size() ; i++ )
core/PhysiCell_phenotype.cpp:		for( int j=0 ; j < pCycle_Model->phase_links[i].size() ; j++ )
core/PhysiCell_phenotype.cpp:			inverse_index_maps[i][ pCycle_Model->phase_links[i][j].end_phase_index ] = j;
core/PhysiCell_phenotype.cpp:			transition_rates[i].resize( pCycle_Model->phase_links[i].size() ); 
core/PhysiCell_phenotype.cpp:			os << "\tPhase " << j << " (" << phases[j].name << ") with rate " << data.transition_rate(i,j) << " " << data.time_units << "^-1; " << std::endl; 
core/PhysiCell_phenotype.cpp:					// pCell->flag_for_division();
core/PhysiCell_phenotype.cpp:					// pCell->flag_for_removal(); 
core/PhysiCell_phenotype.cpp:	return pCycle_Model->phases[current_phase_index]; 
core/PhysiCell_phenotype.cpp:	// reference values: MCF-7 (1/min)
core/PhysiCell_phenotype.cpp:	return rates.size() - 1; 
core/PhysiCell_phenotype.cpp:	return rates.size() - 1; 
core/PhysiCell_phenotype.cpp:		if( models[i]->code == code )
core/PhysiCell_phenotype.cpp:		if( models[i]->name == name )
core/PhysiCell_phenotype.cpp:	pCycle_Model->advance_model( pCell, phenotype , dt ); 
core/PhysiCell_phenotype.cpp:	// reference parameter values for MCF-7, in cubic microns 
core/PhysiCell_phenotype.cpp:	solid = total-fluid; 
core/PhysiCell_phenotype.cpp:	nuclear_solid = nuclear - nuclear_fluid;
core/PhysiCell_phenotype.cpp:	cytoplasmic = total - nuclear;
core/PhysiCell_phenotype.cpp:	cytoplasmic_solid = cytoplasmic - cytoplasmic_fluid; 
core/PhysiCell_phenotype.cpp:	cytoplasmic_to_nuclear_ratio = cytoplasmic / ( 1e-16 + nuclear);
core/PhysiCell_phenotype.cpp:	// reference values for MCF-7, based on 
core/PhysiCell_phenotype.cpp://	std::cout << "----------------" << std::endl; 
core/PhysiCell_phenotype.cpp:	temp2 -= temp1; //  1 - sqrt( alpha_CCA / alpha_CCR );
core/PhysiCell_phenotype.cpp:	s_relative *= temp2; // 2*( 1 - sqrt( alpha_CCA / alpha_CCR ) ); 
core/PhysiCell_phenotype.cpp:	temp2 -= temp1; // 1 - sqrt( alpha_CCA / alpha_CCR )/f;
core/PhysiCell_phenotype.cpp:	s_relative /= temp2; // 2*( 1 - sqrt( alpha_CCA / alpha_CCR ) ) / ( 1-1/f) ; 
core/PhysiCell_phenotype.cpp:	temp2 -= temp1; // 1 - s_relative/2.0 
core/PhysiCell_phenotype.cpp:	temp1 *= -1.0; // -s_relative/(2*relative_maximum_adhesion_distance); 
core/PhysiCell_phenotype.cpp:	temp1 += 1.0; // 1.0 -s_relative/(2*relative_maximum_adhesion_distance); 
core/PhysiCell_phenotype.cpp:// set the cell-cell equilibrium spacing, accomplished by changing the 
core/PhysiCell_phenotype.cpp:// cell-cell adhesion strength, while leaving the cell-cell repulsion 
core/PhysiCell_phenotype.cpp:	temp2 -= temp1; // 1 - s_relative/2.0 
core/PhysiCell_phenotype.cpp:	temp1 *= -1.0; // -s_relative/(2*relative_maximum_adhesion_distance); 
core/PhysiCell_phenotype.cpp:	temp1 += 1.0; // 1.0 -s_relative/(2*relative_maximum_adhesion_distance); 
core/PhysiCell_phenotype.cpp:	secretion_rates.resize( pMicroenvironment->number_of_densities() , 0.0 ); 
core/PhysiCell_phenotype.cpp:	uptake_rates.resize( pMicroenvironment->number_of_densities() , 0.0 ); 
core/PhysiCell_phenotype.cpp:	saturation_densities.resize( pMicroenvironment->number_of_densities() , 0.0 ); 
core/PhysiCell_phenotype.cpp:		if( pCell->get_microenvironment() )
core/PhysiCell_phenotype.cpp:			sync_to_microenvironment( pCell->get_microenvironment() ); 
core/PhysiCell_phenotype.cpp:	if( pCell->secretion_rates != &secretion_rates )
core/PhysiCell_phenotype.cpp:		delete pCell->secretion_rates; 
core/PhysiCell_phenotype.cpp:		delete pCell->uptake_rates; 
core/PhysiCell_phenotype.cpp:		delete pCell->saturation_densities; 
core/PhysiCell_phenotype.cpp:		pCell->secretion_rates = &secretion_rates; 
core/PhysiCell_phenotype.cpp:		pCell->uptake_rates = &uptake_rates; 
core/PhysiCell_phenotype.cpp:		pCell->saturation_densities = &saturation_densities; 
core/PhysiCell_phenotype.cpp:		pCell->set_total_volume( phenotype.volume.total ); 
core/PhysiCell_phenotype.cpp:		pCell->set_internal_uptake_constants( dt );
core/PhysiCell_phenotype.cpp:	pCell->simulate_secretion_and_uptake( pMicroenvironment , dt ); 
core/PhysiCell_phenotype.cpp:	Dirichlet_condition_vector.assign( pMicroenvironment->number_of_densities() , 0.0 ); 
core/PhysiCell_phenotype.cpp:	// set a far-field value for oxygen (assumed to be in the first field)
core/PhysiCell_phenotype.cpp:	X_range[0] *= -1.0;
core/PhysiCell_phenotype.cpp:	Y_range[0] *= -1.0;
core/PhysiCell_phenotype.cpp:	Z_range[0] *= -1.0;
core/PhysiCell_phenotype.cpp:		default_microenvironment_options.Z_range[0] = -default_microenvironment_options.dz/2.0; 
core/PhysiCell_phenotype.cpp:		int J = microenvironment.mesh.y_coordinates.size()-1;
core/PhysiCell_phenotype.cpp:	int I = microenvironment.mesh.x_coordinates.size()-1;
core/PhysiCell_phenotype.cpp:	for( int j=1; j < microenvironment.mesh.y_coordinates.size()-1 ; j++ )
core/PhysiCell_phenotype.cpp:	// if 3-D, also along the corresponding additional faces 
core/PhysiCell_phenotype.cpp:		for( int k=1 ; k < microenvironment.mesh.z_coordinates.size()-1 ; k++ )
core/PhysiCell_phenotype.cpp:			int i = microenvironment.mesh.x_coordinates.size()-1;
core/PhysiCell_phenotype.cpp:			for( int j=1; j < microenvironment.mesh.y_coordinates.size()-1 ; j++ )
core/PhysiCell_standard_models.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_standard_models.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_standard_models.cpp:# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
core/PhysiCell_standard_models.cpp:#    llelized diffusive transport solver for 3-D biological simulations,      #
core/PhysiCell_standard_models.cpp:#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730   #
core/PhysiCell_standard_models.cpp:# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
core/PhysiCell_standard_models.cpp:# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
core/PhysiCell_standard_models.cpp:	// remain in the non-lysed state / phase if volume has not exceeded the 
core/PhysiCell_standard_models.cpp:	Ki67_basic.add_phase( PhysiCell_constants::Ki67_negative , "Ki67-" ); 
core/PhysiCell_standard_models.cpp:	Ki67_basic.add_phase_link( 0 , 1 , NULL ); // - to +
core/PhysiCell_standard_models.cpp:	Ki67_basic.add_phase_link( 1 , 0 , NULL ); // + to - 
core/PhysiCell_standard_models.cpp:	Ki67_basic.transition_rate(0,1) = 1.0/(4.59*60.0); // MCF10A cells are ~4.59 hours in Ki67- state
core/PhysiCell_standard_models.cpp:	Ki67_advanced.add_phase( PhysiCell_constants::Ki67_negative , "Ki67-" ); 
core/PhysiCell_standard_models.cpp:	Ki67_advanced.add_phase_link( 0 , 1 , NULL ); // - to +
core/PhysiCell_standard_models.cpp:	Ki67_advanced.add_phase_link( 1 , 2 , NULL ); // + (pre-mitotic) to + (post-mitotic) 
core/PhysiCell_standard_models.cpp:	Ki67_advanced.add_phase_link( 2 , 0 , NULL ); // + to - 
core/PhysiCell_standard_models.cpp:	Ki67_advanced.transition_rate(0,1) = 1.0/(3.62*60.0); // MCF10A cells ~3.62 hours in Ki67- in this fitted model
core/PhysiCell_standard_models.cpp:	cycling_quiescent.name = "Cycling-Quiescent model"; 
core/PhysiCell_standard_models.cpp:	cycling_quiescent.transition_rate(0,1) = 1.0/(4.59*60.0); // MCF10A cells are ~4.59 hours in Ki67- state
core/PhysiCell_standard_models.cpp:		( phenotype.volume.target_fluid_fraction * phenotype.volume.total - phenotype.volume.fluid );
core/PhysiCell_standard_models.cpp:	phenotype.volume.cytoplasmic_fluid = phenotype.volume.fluid - phenotype.volume.nuclear_fluid; 
core/PhysiCell_standard_models.cpp:		(phenotype.volume.target_solid_nuclear - phenotype.volume.nuclear_solid );    
core/PhysiCell_standard_models.cpp:		( phenotype.volume.target_solid_cytoplasmic - phenotype.volume.cytoplasmic_solid );	
core/PhysiCell_standard_models.cpp:		* (1- phenotype.volume.calcified_fraction);
core/PhysiCell_standard_models.cpp:	if( pCell->functions.add_cell_basement_membrane_interactions )
core/PhysiCell_standard_models.cpp:		pCell->functions.add_cell_basement_membrane_interactions(pCell, phenotype,dt);
core/PhysiCell_standard_models.cpp:	pCell->state.simple_pressure = 0.0; 
core/PhysiCell_standard_models.cpp:	std::vector<Cell*>::iterator end = pCell->get_container()->agent_grid[pCell->get_current_mechanics_voxel_index()].end();
core/PhysiCell_standard_models.cpp:	for(neighbor = pCell->get_container()->agent_grid[pCell->get_current_mechanics_voxel_index()].begin(); neighbor != end; ++neighbor)
core/PhysiCell_standard_models.cpp:		pCell->add_potentials(*neighbor);
core/PhysiCell_standard_models.cpp:		pCell->get_container()->underlying_mesh.moore_connected_voxel_indices[pCell->get_current_mechanics_voxel_index()].end();
core/PhysiCell_standard_models.cpp:		pCell->get_container()->underlying_mesh.moore_connected_voxel_indices[pCell->get_current_mechanics_voxel_index()].begin();
core/PhysiCell_standard_models.cpp:		if(!is_neighbor_voxel(pCell, pCell->get_container()->underlying_mesh.voxels[pCell->get_current_mechanics_voxel_index()].center, pCell->get_container()->underlying_mesh.voxels[*neighbor_voxel_index].center, *neighbor_voxel_index))
core/PhysiCell_standard_models.cpp:		end = pCell->get_container()->agent_grid[*neighbor_voxel_index].end();
core/PhysiCell_standard_models.cpp:		for(neighbor = pCell->get_container()->agent_grid[*neighbor_voxel_index].begin();neighbor != end; ++neighbor)
core/PhysiCell_standard_models.cpp:			pCell->add_potentials(*neighbor);
core/PhysiCell_standard_models.cpp:	pCell->update_motility_vector(dt); 
core/PhysiCell_standard_models.cpp:	pCell->velocity += phenotype.motility.motility_vector; 
core/PhysiCell_standard_models.cpp:	if( pCell->functions.calculate_distance_to_membrane == NULL )
core/PhysiCell_standard_models.cpp:	double distance = pCell->functions.calculate_distance_to_membrane(pCell,phenotype,dt); //Note that the distance_to_membrane function must set displacement values (as a normal vector)
core/PhysiCell_standard_models.cpp:		temp_a= (1- distance/max_interactive_distance);
core/PhysiCell_standard_models.cpp:		temp_a*=-phenotype.mechanics.cell_BM_adhesion_strength;
core/PhysiCell_standard_models.cpp:		temp_r = (1- distance/phenotype.geometry.radius);
core/PhysiCell_standard_models.cpp:	if( fabs( temp_r ) < 1e-16 )
core/PhysiCell_standard_models.cpp:	axpy( &( pCell->velocity ) , temp_r , pCell->displacement ); 
core/PhysiCell_standard_models.cpp:	pCell->state.orientation[0] = 0.0; 
core/PhysiCell_standard_models.cpp:	pCell->state.orientation[1] = 0.0; 
core/PhysiCell_standard_models.cpp:	pCell->state.orientation[2] = 1.0;
core/PhysiCell_standard_models.cpp:	static int oxygen_substrate_index = pCell->get_microenvironment()->find_density_index( "oxygen" ); 
core/PhysiCell_standard_models.cpp:	double pO2 = (pCell->nearest_density_vector())[oxygen_substrate_index]; // PhysiCell_constants::oxygen_index]; 
core/PhysiCell_standard_models.cpp:	int n = pCell->phenotype.cycle.current_phase_index(); 
core/PhysiCell_standard_models.cpp:	if( pO2 < pCell->parameters.o2_proliferation_saturation )
core/PhysiCell_standard_models.cpp:		multiplier = ( pO2 - pCell->parameters.o2_proliferation_threshold ) 
core/PhysiCell_standard_models.cpp:			/ ( pCell->parameters.o2_proliferation_saturation - pCell->parameters.o2_proliferation_threshold );
core/PhysiCell_standard_models.cpp:	if( pO2 < pCell->parameters.o2_proliferation_threshold )
core/PhysiCell_standard_models.cpp:		pCell->parameters.pReference_live_phenotype->cycle.data.transition_rate(start_phase_index,end_phase_index);
core/PhysiCell_standard_models.cpp:	if( pO2 < pCell->parameters.o2_necrosis_threshold )
core/PhysiCell_standard_models.cpp:		multiplier = ( pCell->parameters.o2_necrosis_threshold - pO2 ) 
core/PhysiCell_standard_models.cpp:			/ ( pCell->parameters.o2_necrosis_threshold - pCell->parameters.o2_necrosis_max );
core/PhysiCell_standard_models.cpp:	if( pO2 < pCell->parameters.o2_necrosis_max )
core/PhysiCell_standard_models.cpp:	pCell->phenotype.death.rates[necrosis_index] = multiplier * pCell->parameters.max_necrosis_rate; 
core/PhysiCell_utilities.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_utilities.cpp:#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
core/PhysiCell_utilities.cpp:# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
core/PhysiCell_utilities.cpp:#    llelized diffusive transport solver for 3-D biological simulations,      #
core/PhysiCell_utilities.cpp:#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730   #
core/PhysiCell_utilities.cpp:# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
core/PhysiCell_utilities.cpp:# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
core/PhysiCell_utilities.cpp:	return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]) + (p1[2]-p2[2])*(p1[2]-p2[2]);
